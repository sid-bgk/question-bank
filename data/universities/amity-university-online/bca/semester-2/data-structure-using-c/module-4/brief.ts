import { Brief } from '../../../../../../types';

export const brief: Brief[] = [
  {
    "question": "Explain the concept and implementation of a binary search tree (BST), including its key operations like insertion, deletion, and search.",
    "answer": "A **binary search tree (BST)** is a special kind of binary tree in which the left subtree of a node contains only nodes with values less than the node’s key, while the right subtree contains only nodes with values greater than the node’s key. This structure ensures efficient searching, insertion, and deletion, typically achieving **O(log n)** time complexity in a balanced BST.\n\n**Insertion** in a BST starts at the root and recursively (or iteratively) compares the value to be inserted with the current node’s value. If the value is smaller, the algorithm moves to the left subtree; otherwise, it moves to the right subtree. The new node is inserted at the correct leaf position where the left or right child is `NULL`.\n\n**Deletion** in a BST has three cases:\n1. If the node to be deleted is a **leaf**, it can simply be removed.\n2. If the node has **one child**, it is replaced by its child.\n3. If the node has **two children**, it is replaced by its in-order successor (the smallest node in the right subtree) or in-order predecessor (the largest node in the left subtree), and the successor/predecessor is then deleted.\n\n**Search** operation starts at the root, comparing the key with the node’s value. If the key is smaller, the search continues to the left subtree; if larger, to the right subtree, and it continues until the key is found or the subtree is empty.\n\nHere’s a simple C code snippet for insertion and search:\n\n```c\nvoid insert(node **tree, int val) {\n    if (!(*tree)) {\n        *tree = malloc(sizeof(node));\n        (*tree)->data = val;\n        (*tree)->left = (*tree)->right = NULL;\n    } else if (val < (*tree)->data) {\n        insert(&(*tree)->left, val);\n    } else {\n        insert(&(*tree)->right, val);\n    }\n}\n\nnode* search(node *tree, int val) {\n    if (!tree) return NULL;\n    if (val < tree->data) return search(tree->left, val);\n    if (val > tree->data) return search(tree->right, val);\n    return tree;\n}\n```\n\nIn conclusion, BSTs are widely used in scenarios requiring dynamic data with frequent search, insertion, and deletion, making them foundational in data structure learning.",
    "codeBlock": "void insert(node **tree, int val) { if (!(*tree)) { *tree = malloc(sizeof(node)); (*tree)->data = val; (*tree)->left = (*tree)->right = NULL; } else if (val < (*tree)->data) { insert(&(*tree)->left, val); } else { insert(&(*tree)->right, val); } }\n\nnode* search(node *tree, int val) { if (!tree) return NULL; if (val < tree->data) return search(tree->left, val); if (val > tree->data) return search(tree->right, val); return tree; }",
    "language": "C"
  },
  {
    "question": "Discuss the concept of AVL trees, including how balance is maintained and the different types of rotations used.",
    "answer": "An **AVL tree** is a self-balancing binary search tree that ensures the height difference (balance factor) between the left and right subtrees of any node is at most **1**. The balance factor for each node is calculated as **height(left subtree) - height(right subtree)**, and it must be **-1, 0, or 1** for the tree to be considered balanced.\n\nWhen an insertion or deletion causes an imbalance (balance factor beyond -1 or 1), **rotations** are performed to restore the balance. There are four primary types of rotations:\n\n1. **Left Rotation (LL)**: Applied when a node is inserted in the right subtree of the right child (right-right imbalance). The left rotation pivots the unbalanced node’s right child up and the unbalanced node down to the left.\n\n2. **Right Rotation (RR)**: Applied when a node is inserted in the left subtree of the left child (left-left imbalance). The right rotation pivots the unbalanced node’s left child up and the unbalanced node down to the right.\n\n3. **Left-Right Rotation (LR)**: Applied when a node is inserted in the right subtree of the left child (left-right imbalance). It involves a left rotation on the left child followed by a right rotation on the unbalanced node.\n\n4. **Right-Left Rotation (RL)**: Applied when a node is inserted in the left subtree of the right child (right-left imbalance). It involves a right rotation on the right child followed by a left rotation on the unbalanced node.\n\nHere’s a simplified **C** code snippet for a single right rotation:\n\n```c\nstruct node* rightRotate(struct node *y) {\n    struct node *x = y->left;\n    struct node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    return x;\n}\n```\n\nAVL trees ensure that operations like search, insertion, and deletion remain efficient with **O(log n)** time complexity, as the height is always balanced. They are widely used in applications where balanced search performance is essential, such as in database indexing and file systems.\n\nIn summary, AVL trees automatically manage balance after updates, preventing worst-case performance scenarios that arise in unbalanced binary search trees.",
    "codeBlock": "struct node* rightRotate(struct node *y) { struct node *x = y->left; struct node *T2 = x->right; x->right = y; y->left = T2; return x; }",
    "language": "C"
  },
  {
    "question": "Explain the concept of complete binary trees and how they differ from full binary trees.",
    "answer": "A **complete binary tree** is a binary tree in which all the levels are completely filled except possibly the last level, which is filled from left to right. This structure ensures that there are no gaps in the leftmost positions, leading to an efficient and compact memory representation.\n\nIn contrast, a **full binary tree** (or proper binary tree) is a binary tree in which every node has either 0 or 2 children. In a full binary tree, there are no nodes with only one child.\n\nHere’s a summary of their differences:\n- In a complete binary tree, the last level is filled from the left, but the last level itself may not be fully filled. In a full binary tree, all nodes must have exactly zero or two children.\n- A full binary tree can be complete, but a complete binary tree is not necessarily full if some nodes in the last level have only one child.\n\nComplete binary trees are significant in data structures like **heaps** because they allow efficient memory storage and traversal (like level-order traversals or heap operations). For example, binary heaps, which are typically implemented as arrays, rely on the property of complete binary trees to represent the parent-child relationship without explicit pointers.\n\nBelow is a quick **C** snippet to show a condition for checking completeness of a binary tree using index:\n\n```c\nbool checkComplete(struct Node *root, int index, int totalNodes) {\n    if (root == NULL) return true;\n    if (index >= totalNodes) return false;\n    return checkComplete(root->left, 2 * index + 1, totalNodes) && checkComplete(root->right, 2 * index + 2, totalNodes);\n}\n```\n\nIn summary, complete binary trees optimize space and traversal patterns, while full binary trees impose strict structural rules that are not always necessary for certain applications. Understanding these distinctions is vital for using the right type of binary tree in real-world data structure implementations.",
    "codeBlock": "bool checkComplete(struct Node *root, int index, int totalNodes) { if (root == NULL) return true; if (index >= totalNodes) return false; return checkComplete(root->left, 2 * index + 1, totalNodes) && checkComplete(root->right, 2 * index + 2, totalNodes); }",
    "language": "C"
  },
  {
    "question": "Describe the implementation and significance of the adjacency matrix and adjacency list representations for graphs.",
    "answer": "Graphs are essential data structures used to represent networks of connected nodes (vertices) and edges. There are two primary ways to represent graphs in computer memory: the **adjacency matrix** and the **adjacency list**.\n\nAn **adjacency matrix** is a 2D array where each cell `adj[i][j]` indicates the presence (or absence) of an edge between vertex `i` and vertex `j`. For undirected graphs, this matrix is symmetric. For example, if there’s an edge between vertex 0 and 1, both `adj[0][1]` and `adj[1][0]` are set to 1 (or the weight if the graph is weighted). Adjacency matrices provide **O(1)** time complexity to check if an edge exists between any two vertices, but they consume **O(V²)** space, which can be inefficient for sparse graphs.\n\nIn contrast, an **adjacency list** uses an array of linked lists. Each index of the array represents a vertex, and the linked list at that index contains all adjacent vertices. This representation is memory efficient for sparse graphs because it only stores existing edges. Checking for edge existence can take **O(V)** time in the worst case, but for sparse graphs, adjacency lists are more practical.\n\nHere’s a snippet showing the structure for an adjacency list in **C**:\n\n```c\n#define MAX_VERTICES 50\ntypedef struct node *node_pointer;\ntypedef struct node {\n    int vertex;\n    struct node *link;\n} Node;\nnode_pointer graph[MAX_VERTICES];\n```\n\nIn summary, adjacency matrices are preferable when quick edge lookups are needed and space is not a constraint, while adjacency lists are more suitable for sparse graphs and conserve space by avoiding unnecessary storage of absent edges. Understanding these trade-offs is crucial for efficient graph algorithm implementation, such as BFS, DFS, or shortest path algorithms like Warshall’s or Dijkstra’s algorithm.",
    "codeBlock": "#define MAX_VERTICES 50 typedef struct node *node_pointer; typedef struct node { int vertex; struct node *link; } Node; node_pointer graph[MAX_VERTICES];",
    "language": "C"
  },
  {
    "question": "Discuss Prim’s algorithm for finding the Minimum Spanning Tree (MST) of a graph and its implementation details.",
    "answer": "Prim’s algorithm is a greedy algorithm used to find the **Minimum Spanning Tree (MST)** of a connected, weighted, undirected graph. The MST is a subset of the edges that connects all the vertices with the minimum total edge weight and no cycles.\n\nPrim’s algorithm starts with an arbitrary vertex and grows the MST by selecting the minimum weight edge that connects a vertex already in the MST to a vertex not yet included. At each iteration, the algorithm updates the minimum weight edges connecting the included vertices to the excluded ones.\n\nThe implementation typically uses three arrays:\n- `key[]`: Stores the minimum edge weight to connect a vertex to the MST.\n- `mstSet[]`: A boolean array to track vertices included in the MST.\n- `parent[]`: To store the MST structure by keeping the parent of each vertex.\n\nHere’s a simplified **C** implementation:\n\n```c\nvoid primMST(int graph[V][V]) {\n    int parent[V], key[V];\n    bool mstSet[V];\n    for (int i = 0; i < V; i++) {\n        key[i] = INT_MAX;\n        mstSet[i] = false;\n    }\n    key[0] = 0; // Start from the first vertex\n    parent[0] = -1;\n\n    for (int count = 0; count < V - 1; count++) {\n        int u = minKey(key, mstSet);\n        mstSet[u] = true;\n        for (int v = 0; v < V; v++) {\n            if (graph[u][v] && !mstSet[v] && graph[u][v] < key[v]) {\n                parent[v] = u;\n                key[v] = graph[u][v];\n            }\n        }\n    }\n}\n```\n\nPrim’s algorithm ensures the resulting MST includes all vertices with the minimum total weight without forming cycles. The use of a **priority queue** can further optimize the algorithm’s performance. Understanding and implementing Prim’s algorithm is fundamental in network design, computer networks, and optimization problems where minimum connections are desired.",
    "codeBlock": "void primMST(int graph[V][V]) { int parent[V], key[V]; bool mstSet[V]; for (int i = 0; i < V; i++) { key[i] = INT_MAX; mstSet[i] = false; } key[0] = 0; parent[0] = -1; for (int count = 0; count < V - 1; count++) { int u = minKey(key, mstSet); mstSet[u] = true; for (int v = 0; v < V; v++) { if (graph[u][v] && !mstSet[v] && graph[u][v] < key[v]) { parent[v] = u; key[v] = graph[u][v]; } } } }",
    "language": "C"
  }
];
