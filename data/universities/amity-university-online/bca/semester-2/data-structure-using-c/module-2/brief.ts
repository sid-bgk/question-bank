import { Brief } from '../../../../../../types';

export const brief: Brief[] = [
  {
    "question": "Explain the working principle of stacks in data structures and how they are implemented using arrays in C. Include code examples and discuss the potential issues of overflow and underflow.",
    "answer": "A stack is a linear data structure that follows the Last In, First Out (LIFO) principle, where the last element inserted is the first one to be removed. This structure is analogous to a stack of plates where the plate placed last on top is the first to be removed. In computer memory, a stack can be implemented using arrays or linked lists.\n\nIn an array-based stack implementation in C, an array is used to store the stack elements and a variable `top` is used to track the index of the top element. Initially, the stack is empty, and `top` is set to -1. To push an element, `top` is incremented, and the element is placed at the `top` index. To pop an element, the element at `top` is removed, and `top` is decremented.\n\nHowever, this implementation has limitations, specifically stack overflow and underflow. **Stack overflow** occurs when trying to push an element into a full stack, and **stack underflow** occurs when trying to pop an element from an empty stack.\n\nHere’s a sample code snippet illustrating stack operations:\n\n```c\n#include <stdio.h>\n#define SIZE 5\nint stack[SIZE], top = -1;\n\nvoid push(int value) {\n    if(top == SIZE - 1) {\n        printf(\"Stack Overflow\\n\");\n    } else {\n        stack[++top] = value;\n    }\n}\n\nint pop() {\n    if(top == -1) {\n        printf(\"Stack Underflow\\n\");\n        return -1;\n    } else {\n        return stack[top--];\n    }\n}\n\nint main() {\n    push(10);\n    push(20);\n    printf(\"Popped element: %d\\n\", pop());\n    return 0;\n}\n```\n\nThis code pushes two elements onto the stack and pops one, handling both overflow and underflow conditions appropriately. By carefully managing the `top` variable and checking conditions, stack operations can be implemented safely and efficiently in C.",
    "codeBlock": "int stack[SIZE], top = -1;\nvoid push(int value) {\n    if(top == SIZE - 1) printf(\"Stack Overflow\\n\");\n    else stack[++top] = value;\n}\n\nint pop() {\n    if(top == -1) printf(\"Stack Underflow\\n\");\n    else return stack[top--];\n}",
    "language": "C"
  },
  {
    "question": "Discuss the differences between infix, prefix, and postfix notations for expressions. Provide examples and explain how infix expressions are converted to postfix notation using stacks.",
    "answer": "Expressions in mathematics and programming can be represented in three notations: **infix**, **prefix**, and **postfix**.\n\n✅ **Infix Notation**: This is the most common form, where the operator is placed between operands (e.g., `A + B`). It’s intuitive for humans but not suitable for direct evaluation by computers because of operator precedence and parentheses.\n\n✅ **Prefix Notation**: Also called Polish notation, it places the operator before the operands (e.g., `+ A B`). Prefix expressions eliminate the need for parentheses since the operator’s position determines the order of operations.\n\n✅ **Postfix Notation**: Also called Reverse Polish Notation (RPN), it places the operator after the operands (e.g., `A B +`). Like prefix notation, postfix expressions are unambiguous and can be evaluated easily using stacks.\n\nThe document explains converting infix to postfix using stacks, which is a common use case of the stack data structure.\n\n**Infix to Postfix Conversion Algorithm:**\n1. Scan the expression from left to right.\n2. If the token is an operand, add it to the output.\n3. If the token is an operator:\n   - Pop and add to output all operators from the stack that have higher or equal precedence.\n   - Push the scanned operator onto the stack.\n4. If the token is '(', push it onto the stack.\n5. If the token is ')', pop and add to output until '(' is found.\n6. After the expression ends, pop remaining operators to output.\n\nExample: Infix `(A+B)*C`  \nPostfix: `A B + C *`\n\n**C Implementation Snippet:**\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n#define SIZE 100\nchar stack[SIZE];\nint top = -1;\n\nvoid push(char c) { stack[++top] = c; }\nchar pop() { return stack[top--]; }\n\nint main() {\n    char infix[] = \"(A+B)*C\";\n    // Conversion logic here\n    return 0;\n}\n```\n\nThis approach uses the stack to handle operators and parentheses while converting the expression. The stack ensures that operators are added to the output based on their precedence, ensuring correct evaluation order.\n\nBy understanding these three notations and conversion methods, programmers can effectively parse and evaluate expressions in different formats.",
    "codeBlock": "char stack[SIZE]; int top = -1;\nvoid push(char c) { stack[++top] = c; }\nchar pop() { return stack[top--]; }",
    "language": "C"
  },
  {
    "question": "Describe the concept of queues in data structures. How are queues implemented using arrays in C? Include important functions like enqueue, dequeue, and peek, and discuss how overflow and underflow conditions are handled.",
    "answer": "A **queue** is a linear data structure that follows the **First In, First Out (FIFO)** principle, where the first element added to the queue is the first one to be removed. This makes it analogous to a line of people waiting for a service, where the person at the front leaves first, and new arrivals join at the rear.\n\nQueues are implemented using arrays or linked lists. In an **array-based implementation** in C, two pointers (or indices), `front` and `rear`, are used to keep track of the queue's front and rear. Initially, both are set to -1 to indicate an empty queue.\n\n### Basic Operations:\n✅ **Enqueue**: Inserts an element at the rear of the queue. Before enqueueing, it’s crucial to check if the queue is full (overflow condition). If the queue is empty, `front` and `rear` are set to 0.\n\n✅ **Dequeue**: Removes an element from the front of the queue. Before dequeuing, it’s important to check if the queue is empty (underflow condition). After deleting the last element, both pointers are reset to -1.\n\n✅ **Peek**: Retrieves the front element without removing it.\n\n### C Implementation Snippet:\n```c\n#include <stdio.h>\n#define SIZE 5\nint queue[SIZE], front = -1, rear = -1;\n\nvoid enqueue(int data) {\n    if(rear == SIZE - 1) printf(\"Overflow\\n\");\n    else {\n        if(front == -1) front = 0;\n        queue[++rear] = data;\n    }\n}\n\nvoid dequeue() {\n    if(front == -1) printf(\"Underflow\\n\");\n    else {\n        printf(\"Dequeued: %d\\n\", queue[front]);\n        if(front == rear) front = rear = -1;\n        else front++;\n    }\n}\n\nvoid peek() {\n    if(front != -1) printf(\"Front: %d\\n\", queue[front]);\n}\n```\n\nIn this implementation, **overflow** occurs when `rear` reaches `SIZE-1` and no more insertions can be made. **Underflow** occurs when `front` is -1, meaning no elements exist to dequeue.\n\nUnderstanding these operations and their conditions ensures that queues are implemented correctly and efficiently in C, and they form the basis of many real-world applications like CPU scheduling, resource sharing, and more.",
    "codeBlock": "int queue[SIZE], front = -1, rear = -1;\nvoid enqueue(int data) {\n    if(rear == SIZE - 1) printf(\"Overflow\\n\");\n    else {\n        if(front == -1) front = 0;\n        queue[++rear] = data;\n    }\n}\nvoid dequeue() {\n    if(front == -1) printf(\"Underflow\\n\");\n    else {\n        printf(\"Dequeued: %d\\n\", queue[front]);\n        if(front == rear) front = rear = -1;\n        else front++;\n    }\n}",
    "language": "C"
  },
  {
    "question": "Discuss the concept and implementation of priority queues in C. Explain how insertion and deletion operations work in a priority queue and mention its applications in real-world scenarios.",
    "answer": "A **priority queue** is an advanced form of a queue where each element has an associated priority. In a priority queue, elements with higher priority are removed before elements with lower priority, regardless of their insertion order. If two elements have the same priority, they are dequeued according to their order of arrival.\n\nPriority queues can be implemented using arrays, linked lists, or heaps (for efficient implementations). In the uploaded document, the priority queue is implemented using an array and **heapify** principles to ensure that the highest priority element remains at the top.\n\n### Basic Operations:\n✅ **Insertion (enqueue)**: When a new element is inserted, it’s placed based on its priority. If the queue is empty, `front` and `rear` are set to 0 and the element is inserted. Otherwise, the element is inserted in the appropriate position to maintain the order of priority.\n\n✅ **Deletion (dequeue)**: The element with the highest priority is removed first. In the array implementation, this means removing the front element (since the highest priority is kept at the front). The subsequent elements are shifted to fill the gap.\n\n### Example C Implementation Snippet:\n```c\n#include <stdio.h>\n#define MAX 5\nint pri_que[MAX], front = -1, rear = -1;\n\nvoid insert_by_priority(int data) {\n    if(rear >= MAX - 1) {\n        printf(\"Overflow\\n\");\n        return;\n    }\n    if((front == -1) && (rear == -1)) {\n        front++; rear++;\n        pri_que[rear] = data;\n        return;\n    }\n    int i;\n    for(i = 0; i <= rear; i++) {\n        if(data >= pri_que[i]) {\n            for(int j = rear + 1; j > i; j--)\n                pri_que[j] = pri_que[j - 1];\n            pri_que[i] = data;\n            rear++;\n            return;\n        }\n    }\n    pri_que[++rear] = data;\n}\n```\n\n### Applications:\n✅ **CPU Scheduling**: High-priority processes are scheduled first.\n✅ **Dijkstra's Algorithm**: Finding the shortest path in graphs.\n✅ **Resource Management**: Managing tasks based on priority levels.\n\nThis concept ensures that critical tasks are processed earlier, making it invaluable in real-time and multitasking environments.",
    "codeBlock": "void insert_by_priority(int data) {\n    if(rear >= MAX - 1) printf(\"Overflow\\n\");\n    else if((front == -1) && (rear == -1)) { front++; rear++; pri_que[rear] = data; }\n    else {\n        int i;\n        for(i = 0; i <= rear; i++) {\n            if(data >= pri_que[i]) {\n                for(int j = rear + 1; j > i; j--) pri_que[j] = pri_que[j - 1];\n                pri_que[i] = data;\n                rear++;\n                return;\n            }\n        }\n        pri_que[++rear] = data;\n    }\n}",
    "language": "C"
  },
  {
    "question": "Explain the working of circular queues, how they solve the limitations of linear queues, and discuss their implementation in C. Include details about front and rear pointers and how circular increment works.",
    "answer": "A **circular queue** is a linear data structure that follows the **First In, First Out (FIFO)** principle but solves the space wastage problem that occurs in linear queues. In a linear queue, when elements are dequeued from the front, the empty spaces in the array cannot be reused even if there is space at the beginning. This leads to inefficient memory usage.\n\nCircular queues address this by making the queue's end connect to the front, forming a circle. The `front` and `rear` pointers are updated using modulo arithmetic to wrap around the queue's array when they reach the end, thereby using the freed space efficiently.\n\n### Implementation Details:\n✅ **Front and Rear Pointers**:  \n- Initially, both are set to -1 to denote an empty queue.  \n- When the first element is enqueued, both pointers are set to 0.  \n- **Enqueue**: Rear is incremented by `(rear + 1) % size`.  \n- **Dequeue**: Front is incremented by `(front + 1) % size`.\n\n✅ **Circular Increment**:  \nThe modulo operation ensures that when `rear` or `front` reaches the end of the array (size - 1), the next increment brings it back to 0, making the queue circular.\n\n### Overflow and Underflow:\n✅ **Overflow**: Occurs when `(rear + 1) % size == front`, meaning the queue is full.\n✅ **Underflow**: Occurs when `front` is -1.\n\n### Example C Implementation:\n```c\n#include <stdio.h>\n#define SIZE 5\nint queue[SIZE], front = -1, rear = -1;\n\nvoid enqueue(int data) {\n    if ((rear + 1) % SIZE == front) printf(\"Queue is full\\n\");\n    else {\n        if (front == -1) front = rear = 0;\n        else rear = (rear + 1) % SIZE;\n        queue[rear] = data;\n    }\n}\n\nvoid dequeue() {\n    if (front == -1) printf(\"Queue is empty\\n\");\n    else {\n        printf(\"Dequeued: %d\\n\", queue[front]);\n        if (front == rear) front = rear = -1;\n        else front = (front + 1) % SIZE;\n    }\n}\n```\n\nCircular queues are particularly useful in applications like CPU scheduling, streaming data buffers, and resource sharing. By leveraging the circular nature and modulo arithmetic, they provide an efficient solution to the memory wastage problem seen in linear queues.",
    "codeBlock": "void enqueue(int data) {\n    if ((rear + 1) % SIZE == front) printf(\"Queue is full\\n\");\n    else {\n        if (front == -1) front = rear = 0;\n        else rear = (rear + 1) % SIZE;\n        queue[rear] = data;\n    }\n}\nvoid dequeue() {\n    if (front == -1) printf(\"Queue is empty\\n\");\n    else {\n        printf(\"Dequeued: %d\\n\", queue[front]);\n        if (front == rear) front = rear = -1;\n        else front = (front + 1) % SIZE;\n    }\n}",
    "language": "C"
  }
];
