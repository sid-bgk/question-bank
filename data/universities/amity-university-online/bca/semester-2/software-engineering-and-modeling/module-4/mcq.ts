import { MCQ } from '../../../../../../types';

export const mcq: MCQ[] = [
  {
    "question": "What is the primary objective of software testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To validate software against user requirements and find defects",
      "To reduce software size and complexity",
      "To create detailed documentation",
      "To develop new software features"
    ],
    "answer": "To validate software against user requirements and find defects"
  },
  {
    "question": "Which principle states that 20% of components cause 80% of faults?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Pareto principle",
      "Boundary value principle",
      "Equivalence partitioning",
      "Regression testing principle"
    ],
    "answer": "Pareto principle"
  },
  {
    "question": "What is the primary goal of defect testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To identify circumstances where the program behaves incorrectly",
      "To ensure the system meets non-functional requirements",
      "To evaluate the user interface design",
      "To assess system performance under load"
    ],
    "answer": "To identify circumstances where the program behaves incorrectly"
  },
  {
    "question": "In which testing method do testers create a set of test cases based on the control structure of the software?",
    "codeBlock": "",
    "language": "",
    "options": [
      "White-box testing",
      "Black-box testing",
      "Acceptance testing",
      "Beta testing"
    ],
    "answer": "White-box testing"
  },
  {
    "question": "Which testing approach ensures that updates do not introduce new defects into existing code?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Regression testing",
      "Equivalence partitioning",
      "Smoke testing",
      "Stress testing"
    ],
    "answer": "Regression testing"
  },
  {
    "question": "Which type of testing involves real users using the software in a real-world environment?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Beta testing",
      "Alpha testing",
      "Unit testing",
      "Integration testing"
    ],
    "answer": "Beta testing"
  },
  {
    "question": "Which testing method verifies whether software meets user requirements and expectations?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Validation",
      "Verification",
      "Unit testing",
      "Stress testing"
    ],
    "answer": "Validation"
  },
  {
    "question": "Which characteristic of software testing ensures that tests are repeatable with the same results?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Repeatability",
      "Adaptability",
      "Objectivity",
      "Efficiency"
    ],
    "answer": "Repeatability"
  },
  {
    "question": "What is the main purpose of equivalence partitioning?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To reduce the number of test cases by grouping similar input values",
      "To identify system performance bottlenecks",
      "To check system performance under maximum load",
      "To identify security vulnerabilities"
    ],
    "answer": "To reduce the number of test cases by grouping similar input values"
  },
  {
    "question": "What testing type is most suitable for checking software response to abnormal conditions or high load?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Stress testing",
      "Unit testing",
      "Equivalence partitioning",
      "Smoke testing"
    ],
    "answer": "Stress testing"
  },
  {
    "question": "Which technique divides the input domain into valid and invalid classes?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Equivalence partitioning",
      "Boundary value analysis",
      "Orthogonal array testing",
      "Graph-based testing"
    ],
    "answer": "Equivalence partitioning"
  },
  {
    "question": "What does the cyclomatic complexity metric represent?",
    "codeBlock": "",
    "language": "",
    "options": [
      "The number of independent paths in a program",
      "The number of test cases in a regression suite",
      "The number of defects found in a program",
      "The number of external dependencies in a system"
    ],
    "answer": "The number of independent paths in a program"
  },
  {
    "question": "What type of testing involves combining unit-tested modules to check interactions?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Integration testing",
      "Unit testing",
      "Alpha testing",
      "System testing"
    ],
    "answer": "Integration testing"
  },
  {
    "question": "Which testing method verifies software performance against load and stress conditions?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Performance testing",
      "Alpha testing",
      "Beta testing",
      "Unit testing"
    ],
    "answer": "Performance testing"
  },
  {
    "question": "Which testing approach starts with individual parts and moves up to system-level testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Bottom-up integration testing",
      "Top-down integration testing",
      "Incremental testing",
      "Smoke testing"
    ],
    "answer": "Bottom-up integration testing"
  },
  {
    "question": "In boundary value analysis, which values are typically tested?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Minimum, maximum and just beyond boundaries",
      "Only maximum values",
      "Only random values within the range",
      "Middle of the range only"
    ],
    "answer": "Minimum, maximum and just beyond boundaries"
  },
  {
    "question": "Which testing technique focuses on confirming that the software meets all customer requirements?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Validation testing",
      "Defect testing",
      "Stress testing",
      "Security testing"
    ],
    "answer": "Validation testing"
  },
  {
    "question": "What is the main goal of white-box testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To verify all logic paths and internal code structure",
      "To test user-facing features only",
      "To find bugs in user interface design",
      "To simulate real-world user scenarios"
    ],
    "answer": "To verify all logic paths and internal code structure"
  },
  {
    "question": "Which testing level focuses on testing small, individual units or components of software?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Unit testing",
      "System testing",
      "Acceptance testing",
      "Alpha testing"
    ],
    "answer": "Unit testing"
  },
  {
    "question": "What is the purpose of recovery testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To ensure that a system can recover from failures within acceptable time limits",
      "To test load and stress under maximum conditions",
      "To verify security controls against attacks",
      "To test usability and user interface design"
    ],
    "answer": "To ensure that a system can recover from failures within acceptable time limits"
  },
  {
    "question": "What is smoke testing mainly used for in software testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To quickly verify that the most important functions work properly",
      "To perform thorough security checks",
      "To test a system's performance under heavy load",
      "To analyze the impact of code changes"
    ],
    "answer": "To quickly verify that the most important functions work properly"
  },
  {
    "question": "Which type of testing is best suited for evaluating software behavior during extreme input conditions?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Stress testing",
      "System testing",
      "Acceptance testing",
      "Graph-based testing"
    ],
    "answer": "Stress testing"
  },
  {
    "question": "What does the acronym UAT stand for in software testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "User Acceptance Testing",
      "Unified Automated Testing",
      "Usability and Accessibility Testing",
      "Unit Analysis Testing"
    ],
    "answer": "User Acceptance Testing"
  },
  {
    "question": "In white-box testing, what technique is used to analyze independent paths within a module?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Basis path testing",
      "Black-box testing",
      "Equivalence partitioning",
      "Acceptance testing"
    ],
    "answer": "Basis path testing"
  },
  {
    "question": "What is a key feature of automated testing in a CI/CD pipeline?",
    "codeBlock": "",
    "language": "",
    "options": [
      "It allows consistent and repeatable testing throughout development",
      "It replaces all manual testing",
      "It eliminates the need for testing teams",
      "It focuses only on performance tests"
    ],
    "answer": "It allows consistent and repeatable testing throughout development"
  },
  {
    "question": "Which type of testing is performed to ensure that the software performs well in real-world scenarios with actual users?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Beta testing",
      "Unit testing",
      "Regression testing",
      "Graph-based testing"
    ],
    "answer": "Beta testing"
  },
  {
    "question": "What is the purpose of modular test case design in software testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To create test cases that can be easily reused in different contexts",
      "To test only user interface features",
      "To isolate all system components in testing",
      "To focus only on functional testing"
    ],
    "answer": "To create test cases that can be easily reused in different contexts"
  },
  {
    "question": "What does system testing primarily aim to verify?",
    "codeBlock": "",
    "language": "",
    "options": [
      "That integrated subsystems work together as expected",
      "That individual units function correctly",
      "That the software’s security is robust",
      "That user interface designs meet accessibility standards"
    ],
    "answer": "That integrated subsystems work together as expected"
  },
  {
    "question": "What type of testing helps ensure that a system recovers quickly after a failure?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Recovery testing",
      "Integration testing",
      "Graph-based testing",
      "Gamma testing"
    ],
    "answer": "Recovery testing"
  },
  {
    "question": "Which type of testing focuses on security vulnerabilities and unauthorized access?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Security testing",
      "Boundary value analysis",
      "Equivalence partitioning",
      "Integration testing"
    ],
    "answer": "Security testing"
  },
  {
    "question": "What is the main goal of performance testing in software testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To evaluate the software’s runtime performance in an integrated environment",
      "To validate security controls",
      "To verify code quality using white-box methods",
      "To find usability flaws"
    ],
    "answer": "To evaluate the software’s runtime performance in an integrated environment"
  },
  {
    "question": "Which testing technique tests how software reacts to abnormal or invalid input conditions?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Negative functional testing",
      "Positive functional testing",
      "Acceptance testing",
      "System testing"
    ],
    "answer": "Negative functional testing"
  },
  {
    "question": "What technique divides data into equivalence partitions for testing purposes?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Equivalence partitioning",
      "Graph-based testing",
      "Orthogonal array testing",
      "Boundary value analysis"
    ],
    "answer": "Equivalence partitioning"
  },
  {
    "question": "Which testing method involves testing software based on external behavior and functionality without looking at internal code?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Black-box testing",
      "White-box testing",
      "Integration testing",
      "Regression testing"
    ],
    "answer": "Black-box testing"
  },
  {
    "question": "What is the purpose of using mock objects in unit testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To simulate external dependencies for isolated testing",
      "To automate regression tests",
      "To increase system load for performance testing",
      "To identify usability issues"
    ],
    "answer": "To simulate external dependencies for isolated testing"
  },
  {
    "question": "Which testing approach combines both top-down and bottom-up integration strategies?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Sandwich integration testing",
      "Alpha testing",
      "Stress testing",
      "Beta testing"
    ],
    "answer": "Sandwich integration testing"
  },
  {
    "question": "What is one major advantage of conducting software inspections?",
    "codeBlock": "",
    "language": "",
    "options": [
      "They find multiple faults at once without running the software",
      "They always identify performance issues",
      "They do not require any documentation",
      "They can completely replace functional testing"
    ],
    "answer": "They find multiple faults at once without running the software"
  },
  {
    "question": "In CI/CD processes, why is early testing important?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To quickly catch and fix issues before they propagate",
      "To allow more UI testing only",
      "To avoid conducting security tests",
      "To eliminate regression testing needs"
    ],
    "answer": "To quickly catch and fix issues before they propagate"
  },
  {
    "question": "What does the ‘depth-first’ approach refer to in top-down integration testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Integrating and testing all parts on a major control path before moving sideways",
      "Testing only user interface modules first",
      "Only testing code at the end of the system hierarchy",
      "Releasing software for beta testing before alpha testing"
    ],
    "answer": "Integrating and testing all parts on a major control path before moving sideways"
  },
  {
    "question": "Which testing principle suggests that detailed test planning should begin early in the software lifecycle?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Early test planning",
      "Pareto principle",
      "Equivalence partitioning",
      "Boundary value principle"
    ],
    "answer": "Early test planning"
  },
  {
    "question": "Which testing level involves testing the software after it is fully integrated and before deployment?",
    "codeBlock": "",
    "language": "",
    "options": [
      "System testing",
      "Unit testing",
      "Integration testing",
      "Alpha testing"
    ],
    "answer": "System testing"
  },
  {
    "question": "Which testing principle emphasizes that testing should begin at the smallest level and proceed to the system as a whole?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Testing from small to large",
      "Validation testing",
      "Equivalence partitioning",
      "Stress testing"
    ],
    "answer": "Testing from small to large"
  },
  {
    "question": "Which testing level specifically focuses on testing interactions between modules?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Integration testing",
      "Beta testing",
      "Gamma testing",
      "Recovery testing"
    ],
    "answer": "Integration testing"
  },
  {
    "question": "What is the primary goal of security testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To verify that a system’s defences protect it from unauthorized access",
      "To improve user interface usability",
      "To validate user interface performance",
      "To check stress and load conditions"
    ],
    "answer": "To verify that a system’s defences protect it from unauthorized access"
  },
  {
    "question": "What is the main purpose of acceptance testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To confirm that software meets user requirements and is acceptable for use",
      "To find internal code-level errors",
      "To validate security measures",
      "To identify boundary errors"
    ],
    "answer": "To confirm that software meets user requirements and is acceptable for use"
  },
  {
    "question": "What term refers to simulating unusual behavior or rare events for testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Mock objects",
      "Stress testing",
      "Equivalence partitioning",
      "Graph-based testing"
    ],
    "answer": "Mock objects"
  },
  {
    "question": "Which approach tests a system by running it under maximum resource usage?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Stress testing",
      "Integration testing",
      "Acceptance testing",
      "Recovery testing"
    ],
    "answer": "Stress testing"
  },
  {
    "question": "Which testing activity focuses on testing at boundaries where errors typically occur?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Boundary value analysis",
      "Graph-based testing",
      "Equivalence partitioning",
      "Performance testing"
    ],
    "answer": "Boundary value analysis"
  },
  {
    "question": "What is the main purpose of graph-based testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To verify relationships between software objects using nodes and links",
      "To create performance testing scenarios",
      "To check program recovery capabilities",
      "To create only boundary tests"
    ],
    "answer": "To verify relationships between software objects using nodes and links"
  },
  {
    "question": "What is orthogonal array testing especially useful for?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Testing systems with a small number of discrete input parameters",
      "Testing high-load performance conditions",
      "Validating database security",
      "Checking boundary and equivalence classes"
    ],
    "answer": "Testing systems with a small number of discrete input parameters"
  },
  {
    "question": "What is the purpose of data flow testing in white-box testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To choose paths based on variable definitions and uses",
      "To test data volume under load",
      "To simulate real-user interactions",
      "To validate user interface performance"
    ],
    "answer": "To choose paths based on variable definitions and uses"
  },
  {
    "question": "Which testing type combines real-world conditions and limited final user involvement?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Gamma testing",
      "Alpha testing",
      "Unit testing",
      "Boundary testing"
    ],
    "answer": "Gamma testing"
  },
  {
    "question": "What technique helps identify errors in logic when two or more parameters interact simultaneously?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Double mode fault detection in orthogonal array testing",
      "Boundary value analysis",
      "Alpha testing",
      "Unit testing"
    ],
    "answer": "Double mode fault detection in orthogonal array testing"
  },
  {
    "question": "Which testing principle stresses that third-party testing is often more effective than developer-led testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Independent third-party testing",
      "Boundary testing",
      "Unit testing",
      "Stress testing"
    ],
    "answer": "Independent third-party testing"
  },
  {
    "question": "Which testing principle is related to the notion that testing cannot prove software is error-free?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Testing can show presence, not absence of errors",
      "Pareto principle",
      "Equivalence testing",
      "Usability testing"
    ],
    "answer": "Testing can show presence, not absence of errors"
  },
  {
    "question": "What is the main purpose of recovery testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To verify that the system can recover from failures within acceptable time",
      "To test external user behavior",
      "To validate UI design under stress",
      "To validate integration of modules"
    ],
    "answer": "To verify that the system can recover from failures within acceptable time"
  },
  {
    "question": "What is meant by 'validation' in the context of software testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Building the right product for the user’s needs",
      "Ensuring code correctness regardless of user needs",
      "Improving system security only",
      "Simulating user acceptance tests only"
    ],
    "answer": "Building the right product for the user’s needs"
  },
  {
    "question": "What are test drivers used for in bottom-up integration testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To control and synchronize input/output for testing modules",
      "To stress test the final application",
      "To simulate invalid input values",
      "To validate user experience design"
    ],
    "answer": "To control and synchronize input/output for testing modules"
  },
  {
    "question": "Which testing stage typically follows unit testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Integration testing",
      "Gamma testing",
      "Recovery testing",
      "Security testing"
    ],
    "answer": "Integration testing"
  },
  {
    "question": "What does a requirements traceability matrix (RTM) ensure in testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "That test cases cover all user requirements",
      "That tests are conducted under extreme loads only",
      "That only performance metrics are tracked",
      "That testing starts after development ends"
    ],
    "answer": "That test cases cover all user requirements"
  },
  {
    "question": "Which type of testing is performed without any knowledge of the internal workings of the application?",
    "codeBlock": "",
    "language": "",
    "options": [
      "White-box testing",
      "Integration testing",
      "Black-box testing",
      "Unit testing"
    ],
    "answer": "Black-box testing"
  },
  {
    "question": "In which phase of testing are real users involved to ensure the software meets their needs and works in real-world scenarios?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Alpha testing",
      "Integration testing",
      "Unit testing",
      "Beta testing"
    ],
    "answer": "Beta testing"
  },
  {
    "question": "What is the primary focus of integration testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Testing individual units or components",
      "Verifying the complete system against requirements",
      "Testing the software’s performance under load",
      "Ensuring that combined components work together"
    ],
    "answer": "Ensuring that combined components work together"
  },
  {
    "question": "Which technique involves testing at the boundaries between partitions where errors often occur?",
    "codeBlock": "",
    "language": "",
    "options": [
      "Equivalence partitioning",
      "Boundary value analysis",
      "Decision table testing",
      "State transition testing"
    ],
    "answer": "Boundary value analysis"
  },
  {
    "question": "What is the main objective of alpha testing?",
    "codeBlock": "",
    "language": "",
    "options": [
      "To test the software’s performance under maximum load conditions",
      "To verify that the software is ready for release with a final group of trusted users",
      "To gather feedback from end users in a real-world environment",
      "To perform initial internal testing to identify and fix major issues"
    ],
    "answer": "To perform initial internal testing to identify and fix major issues"
  }
];
